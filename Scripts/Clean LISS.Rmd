---
title: "Clean and Explore LISS Data"
author: "Laurens Bogaardt & Katalin Katona"
date: "2023-12-15"
output:
  html_document:
    df_print: paged
    fig_width: 10
    fig.align: center
    toc: true
    toc_depth: 4
    toc_float: true
    theme: united
    code_folding: show
bibliography: R:\\Projecten\\V02001214 KV2.1.B CZmodellering\\6. Producten\\2022-08-15 - Mathematical Medicine and Biology - A Model of Individual BMI Trajectories\\Submitted\\Bibliography.bib
link-citations: yes
---

<style>
body{text-align: justify}
</style>

# Introduction

The purpose of this document is to clean and explore the data of the Longitudinal Internet studies for the Social Sciences (LISS). This panel is a representative sample of Dutch individuals who participate in monthly Internet surveys [@Scherpenzeel2010]. The panel is based on a true probability sample of households drawn from the population register. Households that could not otherwise participate are provided with a computer and Internet connection. A longitudinal survey is fielded in the panel every year, covering a large variety of domains including health, work, education, income, housing, time use, political views, values and personality.

Before we begin, we need to load the packages _tidyverse_, _haven_, _ggforce_ and _vtable_ [@tidyverse2019; @haven2021; @ggforce2022; @vtable2021].

```{r results = FALSE, message = FALSE, warning = FALSE}
library(tidyverse)
library(haven)
library(ggforce)
library(vtable)
```

# Load Input

The LISS dataset consists of separate questionnaires about various topics. In this document, we will examine the background questionnaires and the health questionnaires.

## Background Data

Let's load the background datasets. These contain general information, such as sex and age, about the participants in the study. The following loops over the names of the files which we will load, extracting only the relevant columns. Throughout the document, we will limit the output in each step. This is because the LISS data are not open source. To request access to the data, please visit [www.lissdata.nl](https://www.lissdata.nl).

```{r}
background.data <- map(
  .x = c(
    "avars_200711_EN_3.0p.sav",
    "avars_200802_EN_3.0p.sav",
    "avars_200811_EN_2.0p.sav",
    "avars_200812_EN_2.0p.sav",
    "avars_200911_EN_2.0p.sav",
    "avars_200912_EN_2.0p.sav",
    "avars_201011_EN_2.0p.sav",
    "avars_201012_EN_2.0p.sav",
    "avars_201111_EN_2.0p.sav",
    "avars_201112_EN_2.0p.sav",
    "avars_201211_EN_1.0p.sav",
    "avars_201212_EN_1.0p.sav",
    "avars_201311_EN_1.0p.sav",
    "avars_201312_EN_1.0p.sav",
    "avars_201507_EN_1.0p.sav",
    "avars_201508_EN_1.0p.sav",
    "avars_201611_EN_1.0p.sav",
    "avars_201612_EN_1.0p.sav",
    "avars_201711_EN_1.0p.sav",
    "avars_201712_EN_1.0p.sav",
    "avars_201811_EN_1.0p.sav",
    "avars_201812_EN_1.0p.sav",
    "avars_201911_EN_1.0p.sav",
    "avars_201912_EN_1.0p.sav",
    "avars_202011_EN_1.0p.sav",
    "avars_202012_EN_1.0p.sav",
    "avars_202111_EN_1.0p.sav",
    "avars_202112_EN_1.1p.sav"
  ),
  .f = ~ read_sav(
    file = paste0("../../2. Data Ruw/LISS/Background [CONFIDENTIAL]/", .),
    col_select = c("nomem_encr", "wave", "geslacht", "gebjaar", "oplcat", "leeftijd")
  ) %>%
    zap_labels() %>%
    rename(
      participant.id = "nomem_encr",
      sex = "geslacht",
      education = "oplcat",
      year.of.birth = "gebjaar",
      age = "leeftijd"
    )
) %>%
  bind_rows()
vtable(background.data, out = "return", missing = TRUE)
```

## Health Data

Participants also filled in health questionnaires which includes information about their length and weight, their smoking habits and their alcohol consumption. The following loops over the names of the files we will load, extracting only the the relevant columns.

```{r}
health.data <- map(
  .x = c(
    "ch07a_2p_EN.sav",
    "ch08b_EN_1.3p.sav",
    "ch09c_EN_1.1p.sav",
    "ch10d_EN_1.0p.sav",
    "ch11e_EN_1.0p.sav",
    "ch12f_EN_1.0p.sav",
    "ch13g_EN_1.0p.sav",
    "ch15h_EN_1.2p.sav",
    "ch16i_EN_1.0p.sav",
    "ch17j_EN_1.0p.sav",
    "ch18k_EN_1.0p.sav",
    "ch19l_EN_1.0p.sav",
    "ch20m_EN_1.0p.sav",
    "ch21n_EN_1.0p.sav"
  ),
  .f = ~ read_sav(
    file = paste0("../../2. Data Ruw/LISS/Health [CONFIDENTIAL]/", .),
    col_select = ends_with(
      c(
        "nomem_encr",
        "_m",
        "016",
        "017",
        "125",
        "126",
        "133",
        "134",
        "135",
        "185",
        "186",
        "187",
        "188",
        "189",
        "190",
        "191",
        "192",
        "193"
      )
    )
  ) %>%
    zap_labels() %>%
    rename(
      participant.id = "nomem_encr",
      wave = ends_with("_m"),
      length = ends_with("016"),
      weight = ends_with("017"),
      ever_smoked = ends_with("125"),
      smokes_now = ends_with("126"),
      n_drinks = ends_with("133"),
      drink_7days = ends_with("134"),
      n_drinks_7days = ends_with("135"),
      str_7days = ends_with("185"),
      hrs_str = ends_with("186"),
      min_str = ends_with("187"),
      mod_7days = ends_with("188"),
      hrs_mod = ends_with("189"),
      min_mod = ends_with("190"),
      walk_7days = ends_with("191"),
      hrs_walk = ends_with("192"),
      min_walk = ends_with("193")
    )
) %>%
  bind_rows()
vtable(health.data, out = "return", missing = TRUE)
```

# Clean Background Data

In this section, we will examine a few aspects of the background dataset. We will find that it contains some missing data and some data which are unusual. Before we fix these issues, let's first filter the data on the participants we actually care about, namely those who also filled in the health questionnaires. This automatically ensures that the variable _participant.id_ cannot be missing.

```{r}
background.data <- background.data %>%
  inner_join(
    health.data %>%
      filter(!is.na(participant.id)) %>%
      distinct(participant.id),
    by = "participant.id"
  )
vtable(background.data, out = "return", missing = TRUE)
```

Let's check if the background data cover everyone who filled in the health questionnaire.

```{r}
health.data %>%
  distinct(participant.id) %>%
  setdiff(
    background.data %>%
      distinct(participant.id)
  ) %>%
  count()
```

It seems one participant will be missed when using the available background data, but this does not seem like a big issue.

## Waves

Let's check if the _wave_ is missing for any row in the dataset.

```{r}
background.data %>%
  summarise(missing = sum(is.na(wave)))
```

Each participant should only have one entry per wave. Let's check this.

```{r}
background.data %>%
  count(participant.id, wave) %>%
  summarise(duplicate = sum(n > 1))
```

## Sex

Let's verify that there are only two sexes. We can immediately check if there are any missing values.

```{r}
background.data %>%
  count(sex)
```

For our purpose, we want males encoded as a _0_ and females as a _1_. Let's change this.

```{r}
background.data <- background.data %>%
  mutate(sex = factor(sex - 1, levels = c(0, 1)))
```

Each participant should only have one value for _sex_ across all waves. Let's count how many times this goes wrong.

```{r}
background.data %>%
  distinct(participant.id, sex) %>%
  count(participant.id, name = "sexes") %>%
  count(sexes)
```

Let's remove these participants from the data.

```{r}
background.data <- background.data %>%
  group_by(participant.id) %>%
  filter(n_distinct(sex) == 1) %>%
  ungroup()
```

## Education

Let's verify that there are only six levels of education. We can immediately check if there are any missing values.

```{r}
background.data %>%
  count(education)
```

Let's now check whether any participant is missing all entries for their level of education.

```{r}
background.data %>%
  group_by(participant.id) %>%
  summarise(
    missing = all(is.na(education)),
    .groups = "drop"
  ) %>%
  count(missing)
```

We will remove these participants from the dataset.

```{r}
background.data <- background.data %>%
  group_by(participant.id) %>%
  filter(!all(is.na(education))) %>%
  ungroup()
```

Each participant should only have one level of education across all waves, but it's possible that some participants increase their level of education as they age. Let's check, for each participant, whether their highest reached level of education does not go down over time.

```{r}
background.data %>%
  group_by(participant.id) %>%
  arrange(wave) %>%
  summarise(
    unsorted = is.unsorted(education, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  count(unsorted)
```

We will remove participants with an unsorted level of education from the dataset.

```{r}
background.data <- background.data %>%
  group_by(participant.id) %>%
  arrange(wave) %>%
  filter(!is.unsorted(education, na.rm = TRUE)) %>%
  ungroup()
```

Participants with an increasing level of education or with missing values will be assigned the last available entry as the one representing their true level of education. Although this imputation is not perfect, it is a simple solution which distorts the data as little as possible.

```{r}
background.data <- background.data %>%
  arrange(participant.id, wave) %>%
  group_by(participant.id) %>%
  mutate(education = last(na.omit(education))) %>%
  ungroup()
```

The LISS dataset measures education using six categories, while we are only interested in a three level scoring, so let's recode the variable. Education will then be measured as the highest level reached where the lowest level, encoded by _1_, applies to people with intermediate secondary education or less, the medium level, encoded by _2_, aggregates higher secondary- and intermediate vocational education and highest level, encoded by _3_, includes higher vocational education and university.

```{r}
background.data <- background.data %>%
  mutate(education = factor(ceiling(education / 2), levels = c(1, 2, 3), ordered = TRUE))
```

## Year of Birth

Let's check if there are any participants who are missing their year of birth.

```{r}
background.data %>%
  summarise(missing = sum(is.na(year.of.birth)))
```

Each participant should only have one year of birth across all waves. Let's count how many times this goes wrong.

```{r}
background.data %>%
  distinct(participant.id, year.of.birth) %>%
  count(participant.id) %>%
  summarise(nonunique = sum(n > 1))
```

Let's remove all participants with an ambiguous year of birth.

```{r}
background.data <- background.data %>%
  group_by(participant.id) %>%
  filter(n_distinct(year.of.birth) == 1) %>%
  ungroup()
```

## Age

Let's check if there are any participants who are missing their age.

```{r}
background.data %>%
  summarise(missing = sum(is.na(age)))
```

The year of birth and the age of the participant are related and should match. Although we do not know the precise date of birth of each participant, a range for the plausible age of a participant can be constructed and compared with the stated age.

```{r}
background.data %>%
  mutate(
    min.age = floor(wave / 100 - year.of.birth) - 1,
    max.age = floor(wave / 100 - year.of.birth)
  ) %>%
  group_by(participant.id) %>%
  summarise(
    mismatch = any(age < min.age | age > max.age),
    .groups = "drop"
  ) %>%
  count(mismatch)
```

Let's remove all participants with inconsistencies with their age and year of birth. The variable _year.of.birth_ is now no longer needed, so it is removed from the dataset.

```{r}
background.data <- background.data %>%
  group_by(participant.id) %>%
  filter(
    all(age >= floor(wave / 100 - year.of.birth) - 1),
    all(age <= floor(wave / 100 - year.of.birth))
  ) %>%
  ungroup() %>%
  select(-year.of.birth)
```

The dataset contains values for the age of the participants which are rounded down to the nearest year. As a simple solution, half a year is added to these values.

```{r}
background.data <- background.data %>%
  mutate(
    age = age + 0.5
  )
```

# Combine with Health Data

The background questionnaires and the health questionnaires were loaded as separate datasets. We need to combine these to form a single dataset.

## Clean Keys

The datasets will be joined on the keys _participant.id_ and _wave_, so we need to verify that the health dataset has no missing values for either these variables, nor duplicate waves.

```{r}
health.data %>%
  summarise(
    missing.participant.id = sum(is.na(participant.id)),
    missing.wave = sum(is.na(wave)),
    duplicate = n() - n_distinct(participant.id, wave)
  )
```

The health data contains participants who we have just removed from the background data during the cleaning process. These should also be removed from the health data.

```{r}
health.data <- health.data %>%
  inner_join(
    background.data %>%
      distinct(participant.id),
    by = "participant.id"
  )
vtable(health.data, out = "return", missing = TRUE)
```

## Join Datasets

Although the participants in both the background data and the health data are the same, there may be waves in the health data for which we do not have any background data of specific participants. Let's count for how many participants this occurs.

```{r}
health.data %>%
  select(participant.id, wave) %>%
  setdiff(
    background.data %>%
      select(participant.id, wave)
  ) %>%
  distinct(participant.id) %>%
  count()
```

If we join the datasets on the _participant.id_ and _wave_ using an inner-join, these participants will be removed from the data. We could attempt to impute the missing values from the information we have from other waves, but given that it applies to only a small number of participants, removing them from the data is not a big issue.

```{r}
liss.data <- background.data %>%
  inner_join(
    health.data,
    by = c("participant.id", "wave")
  ) %>%
  arrange(participant.id, wave)
```

## Clean Waves

The column _wave_ is a concatenation of the year and the month the questionnaire was administered. Let's create a new variable indicating the date on which the questionnaire took place by assuming all waves were administered on the 15th of the month. We can also add a variable indicating the year to which the wave belongs.

```{r}
liss.data <- liss.data %>%
  mutate(
    date = as.Date(paste0(substr(wave, 1, 4), "-", substr(wave, 5, 6), "-15")),
    wave.year = floor(wave / 100) # Remove in main
  )
```

We can check how many health questionnaires the participants filled in per year.

```{r}
liss.data %>%
  count(wave.year, participant.id) %>%
  count(wave.year, n, name = "participants")
```

This can also be visualised in a plot. As seen, the questionnaires were administered in two different months each wave. Most of the time, the year belonging to these paired months is the same. The exception is in 2007 and 2008. The round of February 2008 can be considered part of the wave of 2007. The frequency of the questionnaire was approximately one year, except between 2013 and 2016, when there was a gap, meaning the year 2014 was skipped.

```{r}
ggplot() +
  geom_segment(
    mapping = aes(
      x = date,
      xend = date,
      y = 0,
      yend = 1,
      color = factor(wave.year)
    ),
    data = liss.data %>%
      distinct(wave, date, wave.year)
  ) +
  labs(
    x = "Date",
    colour = "Year"
  ) +
  scale_x_date(
    date_breaks = "1 year",
    date_labels = "%Y"
  ) +
  theme(
    axis.text.y = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank()
  )
```

Let's now verify that the participants filled in only one health questionnaire per year, if we consider the round of February 2008 part of the wave of 2007.

```{r}
liss.data %>%
  mutate(wave.year = if_else(wave == 200802, 2007, wave.year)) %>%
  count(wave.year, participant.id) %>%
  count(wave.year, n, name = "participants")
```

Let's change the year of the wave of February 2008 to be 2007 and let's recode _wave_ to number the waves consecutively, taking into account that 2014 is skipped.

```{r}
liss.data <- liss.data %>%
  mutate(
    wave.year = if_else(wave == 200802, 2007, wave.year),
    wave = recode(
      wave.year,
      `2007` = 1,
      `2008` = 2,
      `2009` = 3,
      `2010` = 4,
      `2011` = 5,
      `2012` = 6,
      `2013` = 7,
      `2015` = 8,
      `2016` = 9,
      `2017` = 10,
      `2018` = 11,
      `2019` = 12,
      `2020` = 13,
      `2021` = 14
    )
  )
```

# Clean Physical Activity

## According to IPAQ guideline

1. Check height and weight data based on data distribution (length data: 0-220, >260; weight data: 0-200, 300, >600).
```{r}
range(liss.data$length, na.rm = T)
range(liss.data$weight, na.rm = T)
```

2. In some cases responses in 'hours' were reported as an equivalent number of 'minutes'. These data are converted to 0.
```{r}
liss.data$hrs_str[liss.data$hrs_str*60 == liss.data$min_str] <- 0
liss.data$hrs_mod[liss.data$hrs_mod*60 == liss.data$min_mod] <- 0
liss.data$hrs_walk[liss.data$hrs_walk*60 == liss.data$min_walk] <- 0
```

3. Correct negative values.
```{r}
liss.data$hrs_walk <- abs(liss.data$hrs_walk)
```

4. Check responses in 'minutes' were not entered in the 'hours': values of 15,30,45,60,and 90 in the 'hours' are converted to 15,30,45,60,90 minutes.
```{r}
### strenuous data
liss.data$min_str[liss.data$hrs_str == 15] <- 15
liss.data$min_str[liss.data$hrs_str == 30] <- 30
liss.data$min_str[liss.data$hrs_str == 45] <- 45
liss.data$min_str[liss.data$hrs_str == 60] <- 60
liss.data$min_str[liss.data$hrs_str == 90] <- 90

liss.data$hrs_str[which(liss.data$hrs_str %in% c(15, 30, 45, 60, 90))] <- 0

### moderate data
liss.data$min_mod[liss.data$hrs_mod == 15] <- 15
liss.data$min_mod[liss.data$hrs_mod == 30] <- 30
liss.data$min_mod[liss.data$hrs_mod == 45] <- 45
liss.data$min_mod[liss.data$hrs_mod == 60] <- 60
liss.data$min_mod[liss.data$hrs_mod == 90] <- 90

liss.data$hrs_mod[which(liss.data$hrs_mod %in% c(15, 30, 45, 60, 90))] <- 0

### walk data
liss.data$min_walk[liss.data$hrs_walk == 15] <- 15
liss.data$min_walk[liss.data$hrs_walk == 30] <- 30
liss.data$min_walk[liss.data$hrs_walk == 45] <- 45
liss.data$min_walk[liss.data$hrs_walk == 60] <- 60
liss.data$min_walk[liss.data$hrs_walk == 90] <- 90

liss.data$hrs_walk[which(liss.data$hrs_walk %in% c(15, 30, 45, 60, 90))] <- 0
```

5. Calculate activity time (minutes per day).
6. Define Valid responses for day per week. If people did not answer the question about days per week, fill the values of time as 0.
7. We assume people sleep 8 hours a day. Total PA should be less than 960.
```{r}
liss.data <- liss.data %>%
  rowwise() %>%
  mutate(
    vig_time = sum(60*hrs_str, min_str, na.rm = T),
    mod_time = sum(60*hrs_mod, min_mod, na.rm = T),
    walk_time = sum(60*hrs_walk, min_walk, na.rm = T)
  ) %>%
  ungroup()

liss.data$vig_time[is.na(liss.data[,"str_7days"])] <- NA
liss.data$mod_time[is.na(liss.data[,"mod_7days"])] <- NA
liss.data$walk_time[is.na(liss.data[,"walk_7days"])] <- NA

liss.data$str_7days[liss.data$vig_time < 10] <- 0
liss.data$mod_7days[liss.data$mod_time < 10] <- 0
liss.data$walk_7days[liss.data$walk_time < 10] <- 0

liss.data$vig_time[liss.data$vig_time > 960] <- NA
liss.data$mod_time[liss.data$mod_time > 960] <- NA
liss.data$walk_time[liss.data$walk_time > 960] <- NA

liss.data <- liss.data %>%
  rowwise() %>%
  mutate(pa_time = sum(vig_time, mod_time, walk_time)) %>%
  ungroup()

head(liss.data)
```

## Calculating outcome variables MVPA and gl
MVPA: Minutes per week moderate- to vigorous- intensity physical activity.
Because walking has a MET value of 3.3, here consider it as moderate intensity PA.
pa.state: if people are sufficiently or insufficiently active according to Dutch guideline (150+ minutes of moderate-intensity activity per week, spread over several days).

```{r}
liss.data <- liss.data %>%
  rowwise() %>%
  mutate(
    MVPA = ifelse(pa_time <= 960, sum(vig_time*str_7days, mod_time*mod_7days, walk_time*walk_7days, na.rm = T), NA),
    days = sum(str_7days, mod_7days, walk_7days, na.rm = T),
    pa.state = ifelse(MVPA >= 150 & days >= 2, 1, 0)
  ) %>%
  ungroup() %>%
  select(-c(str_7days, hrs_str, min_str, mod_7days, hrs_mod, min_mod, walk_7days, hrs_walk, min_walk, vig_time, mod_time, walk_time, pa_time, days))
```

# Clean BMI

In this section, we will examine the columns _length_ and _weight_ from the health questionnaire and construct the new variable _bmi_.

## Age Limit

[Placeholder for text]

```{r}
liss.data <- liss.data %>% # Relocate in main
  mutate(
    length = ifelse(age < 18, NA, length),
    weight = ifelse(age < 18, NA, weight)
  )
```

## Length

Let's now check whether any participant is missing all entries for their length.

```{r}
liss.data %>%
  group_by(participant.id) %>%
  filter(age >= 18) %>% # Remove in main
  summarise(
    missing = all(is.na(length)),
    .groups = "drop"
  ) %>%
  count(missing)
```

We will remove these participants from the dataset.

```{r}
# liss.data <- liss.data %>%
#   group_by(participant.id) %>%
#   filter(!all(is.na(length))) %>%
#   ungroup()
```

Let's now check whether any participant is missing any entry for their length.

```{r}
liss.data %>%
  filter(age >= 18) %>% # Remove in main
  group_by(participant.id) %>%
  summarise(
    missing = any(!is.na(length)) && any(is.na(length)),
    .groups = "drop"
  ) %>%
  count(missing)
```

We can impute the mean length for those waves.

```{r}
liss.data <- liss.data %>%
  group_by(participant.id) %>%
  mutate(
    length = case_when(
      any(!is.na(length)) && any(is.na(length)) ~ mean(length, na.rm = TRUE),
      TRUE ~ length
    )
  ) %>%
  ungroup()
```

Let's check how many participants have an unrealistically high or low length.

```{r}
liss.data %>%
  filter(age >= 18, !is.na(length)) %>% # Remove in main
  group_by(participant.id) %>%
  summarise(
    below = any(length < 140),
    above = any(length > 220),
    .groups = "drop"
  ) %>%
  summarise(
    below = sum(below),
    above = sum(above)
  )
```

Given that the LISS data are self-reported, errors in filling out the questionnaire may occur. So let's remove all participants with an unrealistic length.

```{r}
liss.data <- liss.data %>%
  group_by(participant.id) %>%
  mutate(
    length = length * NA ^ (length < 140 | length > 220)
  ) %>%
  ungroup()
```

Let's check how many participants have large differences in their length over time.

```{r}
liss.data %>%
  filter(age >= 18) %>% # Remove in main
  group_by(participant.id) %>%
  filter(
    sum(!is.na(length)) >= 2
  ) %>%
  summarise(
    large.difference = diff(range(length, na.rm = TRUE)) > 8,
    .groups = "drop"
  ) %>%
  count(large.difference)
```

Let's remove the participants with an unrealistically large difference in their length over time.

```{r}
liss.data <- liss.data %>%
  group_by(participant.id) %>%
  mutate(
    length = length * NA ^ (
      sum(!is.na(length)) >= 2 &&
        diff(range(length, na.rm = TRUE)) > 8
      )
  ) %>%
  ungroup()
```

## Weight

Let's now check whether any participant is missing all entries for their weight.

```{r}
liss.data %>%
  group_by(participant.id) %>%
  filter(age >= 18) %>% # Remove in main
  summarise(
    missing = all(is.na(weight)),
    .groups = "drop"
  ) %>%
  count(missing)
```

We will remove these participants from the dataset.

```{r}
# liss.data <- liss.data %>%
#   group_by(participant.id) %>%
#   filter(!all(is.na(weight))) %>%
#   ungroup()
```

Let's now check whether any participant is missing any entry for their weight.

```{r}
liss.data %>%
  filter(age >= 18) %>% # Remove in main
  group_by(participant.id) %>%
  summarise(
    missing = any(!is.na(weight)) && any(is.na(weight)),
    .groups = "drop"
  ) %>%
  count(missing)
```

It is nearly impossible to impute reasonable values for these entries, so we will remove these waves from the dataset.

```{r}
# liss.data <- liss.data %>%
#   filter(any(!is.na(weight)) && any(is.na(weight)))
```

Let's check how many participants have an unrealistically high or low weight.

```{r}
liss.data %>%
  filter(age >= 18, !is.na(weight)) %>% # Remove in main
  group_by(participant.id) %>%
  summarise(
    below = any(weight < 40),
    above = any(weight > 200),
    .groups = "drop"
  ) %>%
  summarise(
    below = sum(below),
    above = sum(above)
  )
```

Given that the LISS data are self-reported, errors in filling out the questionnaire may occur. So let's remove all participants with an unrealistic weight.

```{r}
liss.data <- liss.data %>%
  group_by(participant.id) %>%
  mutate(
    weight = weight * NA ^ (weight < 40 | weight > 200)
  ) %>%
  ungroup()
```

Let's check how many participants have very large differences in their weight over time.

```{r}
liss.data %>%
  filter(age >= 18) %>% # Remove in main
  group_by(participant.id) %>%
  filter(
    sum(!is.na(weight)) >= 2
  ) %>%
  summarise(
    large.difference = diff(range(weight, na.rm = TRUE)) > 80,
    .groups = "drop"
  ) %>%
  count(large.difference)
```

Let's remove the participants with an unrealistically large difference in their weight over time.

```{r}
liss.data <- liss.data %>%
  group_by(participant.id) %>%
  mutate(
    weight = weight * NA ^ (
      sum(!is.na(weight)) >= 2 &&
        (diff(range(weight, na.rm = TRUE)) > 80)
      )
  ) %>%
  ungroup()
```

## BMI

We can construct the new variable _bmi_ from _length_ and _weight_. These latter two variables may be removed from the dataset, as they are no longer necessary.

```{r}
liss.data <- liss.data %>%
  mutate(bmi = weight / (length / 100) ^ 2) %>%
  select(-length, -weight)
```

In most of their analyses, Statistics Netherlands removes outlying BMI values whereby it uses $14 kg / m^2$ and $50 kg / m^2$ as the lower and upper limits. Let's check whether we have such outliers in our data.

```{r}
liss.data %>%
  summarise(
    below = sum(bmi < 14, na.rm = TRUE),
    above = sum(bmi > 50, na.rm = TRUE),
    min.bmi = min(bmi, na.rm = TRUE),
    max.bmi = max(bmi, na.rm = TRUE)
  )
```
# Clean Smoking

## Smoking status

```{r}
liss.data <- liss.data %>%
  mutate(
    smoking_status = case_when(
      smokes_now == 1 ~ "Smokes",
      smokes_now == 2 ~ "Stopped",
      is.na(smokes_now)==TRUE & is.na(ever_smoked)==FALSE ~ "Never Smoked"
    )
  )
```

## Transitions

I will only look at two adjacent periods at the time and pool all years. If someone filled in the questionnaire in 2007, 2008 and 2009, for example, then he will appear twice in the data set; once with the transition 2007-2008 and once with the transition 2008 - 2009. 

```{r}
transitions.uncorrected <- liss.data %>%
  filter(
    !is.na(ever_smoked),
    wave.year < max(wave.year)
  ) %>%
  select(participant.id, sex, wave.year, smoking_status) %>%
  inner_join(
    liss.data %>%
      filter(!is.na(ever_smoked),
        wave.year > min(wave.year)) %>%
      mutate(wave.year = wave.year - 1) %>%
      select(participant.id, wave.year, smoking_status),
    by = c("participant.id", "wave.year")
  ) %>%
  count(sex, "0" = smoking_status.x, "1" = smoking_status.y) %>%
  mutate(row.id = seq(n())) %>%
  pivot_longer(c("0", "1")) %>%
  mutate(name = as.numeric(name))
transitions.uncorrected
```

[Placeholder for text]

```{r}
ggplot(
  mapping = aes(
    x = name,
    id = row.id,
    split = value,
    value = n
  ),
  data = transitions.uncorrected
) +
  geom_parallel_sets(
    mapping = aes(fill = as.factor(sex)),
    alpha = 0.5,
    axis.width = 0.1
  ) +
  geom_parallel_sets_axes(
    axis.width = 0.1,
    fill = "grey"
  ) +
  geom_parallel_sets_labels() +
  scale_fill_discrete(
    name = "Sex",
    labels = c("Male", "Female")
  ) +
  theme_void()
```

[Placeholder for text]

## Illogical Transitions

[Placeholder for text]

```{r}
transitions<-data.frame()

for (i in c(2007:2013, 2015:2019)) {
  links_t<-liss.data %>%
  {if (i==2013) filter(.,wave.year %in% c(i, i+2) & is.na(ever_smoked)==FALSE) else filter(.,wave.year %in% c(i, i+1) & is.na(ever_smoked)==FALSE)} %>%
  mutate(wave.year=if_else(wave.year==min(wave.year), "source", "target"))%>%
  select(participant.id, smokes_now, wave.year) %>%
  mutate(smokes_now=as.factor(smokes_now)) %>% 
  mutate(smokes_now=case_when(smokes_now ==1 ~ 'smokes', 
                              smokes_now ==2 ~ 'stopped',
                              is.na(smokes_now) ~ 'never smoked')) %>% 
  spread(wave.year, smokes_now) %>%
  filter(is.na(source)==FALSE & is.na(target)==FALSE) %>%
    mutate(wave=i)
  
transitions<-rbind(transitions, links_t)
}

``` 

Transitions 'stopped' -> 'never smoked' and 'smokes' -> 'never smoked' are impossible. They occur in `r transitions %>% filter(source %in% c('stopped', 'smokes') & target=='Never smoked') %>% count()` transitions, which `r (transitions %>% filter(source %in% c('stopped', 'smokes') & target=='never smoked') %>% count()*100)/(transitions %>% count())`% of the total number of transition.


[Placeholder for text]

```{r}

transitions<-transitions %>% mutate(illogical=ifelse((source %in% c('stopped', 'smokes') & target=='never smoked'), TRUE, FALSE))

illog_no<-transitions %>% filter(illogical==TRUE) %>%
  distinct(participant.id) %>% pull(participant.id)


illog_trans<-transitions %>% filter(participant.id %in% illog_no)

illog_trans %>% group_by(participant.id) %>% summarize(pc=mean(illogical)) %>%
  count(pc)

```

[Placeholder for text]

```{r}
illog_trans%>%count(wave)

```

## Correct Transitions

If someone has ever answered 'smokes' or 'stopped', then I correct all 'never smoked' answers of that person in the following years to 'stopped'. This person can have the answer 'smokes' after 'stopped' but not 'never smoked' any more.

```{r}

# search the year when someone stated smoking or stopped smoking (after which he cannot answer 'never smoked')
began_smoke_or_stopped<-liss.data %>% group_by(participant.id) %>% arrange(wave.year) %>% 
  filter(smoking_status %in% c('Stopped', 'Smokes'))  %>%
  filter(wave.year==min(wave.year)) %>% select(participant.id, wave.year) %>% rename(wave_began_stopped=wave.year)

# correct smoking status
liss.data <- liss.data %>%
  left_join(y=began_smoke_or_stopped, by="participant.id") %>% 
  mutate(wave_began_stopped=ifelse(is.na(wave_began_stopped), 9999, wave_began_stopped)) %>%
  mutate(smoking_status_corr=ifelse((wave_began_stopped<wave.year & smoking_status=='Never Smoked'), "Stopped", smoking_status)) %>%
  select(-wave_began_stopped)

```

# Clean Alcohol Consumption

[Placeholder for text]

# Order Rows and Columns

As a final cleaning step, let's reorder the columns and arrange the rows of the dataset.

```{r}
liss.data <- liss.data %>%
  select(participant.id, sex, education, wave, date, age, bmi, wave.year, ever_smoked, smokes_now, n_drinks, drink_7days, n_drinks_7days, MVPA, pa.state, smoking_status, smoking_status_corr) %>%
  arrange(participant.id, wave)
```

# Explore Data

We will examine each variable in the dataset, now that the data have been cleaned. But let's first look at an overview of the dataset.

```{r}
vtable(liss.data, out = "return", missing = TRUE)
```

## Participation

Let's see how many participants we have per wave.

```{r}
liss.participants.by.wave <- liss.data %>%
  group_by(wave) %>%
  count(wave)
liss.participants.by.wave
```

We can visualise this in a plot.

```{r}
ggplot() +
  geom_col(
    mapping = aes(
      x = factor(wave),
      y = n,
      fill = factor(wave)
    ),
    data = liss.participants.by.wave,
    show.legend = FALSE
  ) +
  labs(
    x = "Wave",
    y = "Number of participants"
  )
```

We can also count how many participants participated in all of the waves and how many in fewer.

```{r}
liss.number.of.waves <- liss.data %>%
  count(participant.id, name = "waves") %>%
  count(waves)
liss.number.of.waves
```

We can visualise this in a plot.

```{r}
ggplot() +
  geom_col(
    mapping = aes(
      x = factor(waves),
      y = n,
      fill = factor(waves)
    ),
    data = liss.number.of.waves,
    show.legend = FALSE
  ) +
  labs(
    x = "Waves",
    y = "Number participated"
  )
```

For all participants, we can note whether they participated in a wave or not. If not, the participant was either new and had never previously participated or had done so in the past and stopped participating. This can be used to see at what rate participants enter or leave the panel, between each wave.

```{r}
stratum.per.participant.per.wave <- liss.data %>%
  expand(participant.id, wave) %>%
  left_join(
    liss.data %>%
      select(participant.id, wave) %>%
      mutate(stratum = TRUE),
    by = c("participant.id", "wave")
  ) %>%
  arrange(participant.id, wave) %>%
  group_by(participant.id) %>%
  mutate(
    stratum = case_when(
      is.na(stratum) & cumsum(!is.na(stratum)) == 0 ~ "New",
      is.na(stratum) & cumsum(!is.na(stratum)) > 0 ~ "Out",
      stratum ~ "In"
    ),
    stratum = factor(stratum, levels = c("New", "In", "Out"))
  ) %>%
  ungroup()
vtable(stratum.per.participant.per.wave, out = "return", missing = TRUE)
```

These data can be visualised, showing the transitions in and out of the panel over time.

```{r}
ggplot(
  mapping = aes(
    x = factor(wave),
    id = participant.id,
    split = stratum,
    value = 1,
    fill = stratum
  ),
  data = stratum.per.participant.per.wave
) +
  geom_parallel_sets(
    fill = "grey",
    alpha = 0.5
  ) +
  geom_parallel_sets_axes(axis.width = 0.4) +
  labs(
    x = "Wave",
    fill = ""
  ) +
  theme_void() +
  theme(
    axis.title.x = element_text(margin = margin(t = 4)),
    axis.text.x = element_text(margin = margin(t = -12))
  )
```

## Sex

Let's check, per wave, what the number and percentages of males and females is.

```{r}
liss.prevalence.by.wave.and.sex <- liss.data %>%
  count(wave, sex) %>%
  group_by(wave) %>%
  mutate(
    prevalence = n / sum(n)
  ) %>%
  ungroup()
liss.prevalence.by.wave.and.sex
```

We can visualise this in a plot.

```{r}
ggplot() +
  geom_col(
    mapping = aes(
      x = factor(wave),
      y = prevalence,
      fill = sex
    ),
    data = liss.prevalence.by.wave.and.sex
  ) +
  labs(
    x = "Wave",
    y = "Prevalence"
  ) +
  scale_fill_discrete(
    name = "Sex",
    label = c("0" = "Male", "1" = "Female")
  )
```

## Education

Let's check, per wave, what the number and percentages of each of the three levels of education is.

```{r}
liss.prevalence.by.wave.and.education <- liss.data %>%
  count(wave, education) %>%
  group_by(wave) %>%
  mutate(
    prevalence = n / sum(n)
  ) %>%
  ungroup()
liss.prevalence.by.wave.and.education
```

We can visualise this in a plot.

```{r}
ggplot() +
  geom_col(
    mapping = aes(
      x = factor(wave),
      y = prevalence,
      fill = education
    ),
    data = liss.prevalence.by.wave.and.education
  ) +
  labs(
    x = "Wave",
    y = "Prevalence"
  ) +
  scale_fill_discrete(
    name = "Level of education",
    labels = c("1" = "Low", "2" = "Medium", "3" = "High")
  )
```

## Age

Let's check, per wave, what the minimum, mean and maximum age is.

```{r}
liss.data %>%
  group_by(wave) %>%
  summarise(
    min.age = min(age),
    mean.age = mean(age),
    max.age = max(age),
    .groups = "drop"
  )
```

We can visualise the age distribution in a boxplot.

```{r}
ggplot() +
  geom_boxplot(
    mapping = aes(
      x = factor(wave),
      y = age,
      fill = factor(wave)
    ),
    data = liss.data,
    show.legend = FALSE
  ) +
  labs(
    x = "Wave",
    y = "Age"
  )
```

We can also visualise the probability density of the age distribution by wave.

```{r}
ggplot() + 
  geom_density(
    mapping = aes(
      x = age,
      col = factor(wave)
    ),
    data = liss.data
  ) +
  labs(
    x = "Age",
    y = "Probability density",
    col = "Wave"
  )
```

## BMI

Let's check, per wave, what the minimum, mean and maximum BMI value is.

```{r}
liss.data %>%
  filter(!is.na(bmi)) %>% # Remove in main
  group_by(wave) %>%
  summarise(
    min.bmi = min(bmi),
    mean.bmi = mean(bmi),
    max.bmi = max(bmi),
    .groups = "drop"
  )
```

We can visualise the BMI distribution in a boxplot.

```{r}
ggplot() +
  geom_boxplot(
    mapping = aes(
      x = factor(wave),
      y = bmi,
      fill = factor(wave)
    ),
    data = liss.data %>% filter(!is.na(bmi)), # Remove in main
    show.legend = FALSE
  ) +
  labs(
    x = "Wave",
    y = "BMI"
  )
```

We can also visualise the probability density of the BMI distribution by wave and sex.

```{r}
ggplot() +
  geom_density(
    mapping = aes(
      x = bmi,
      colour = factor(wave)
    ),
    data = liss.data %>%
      filter(
        bmi > 15,
        bmi < 45,
        wave %% 2 == 1
      )
  ) +
  xlim(15, 45) +
  labs(
    x = "BMI",
    y = "Probability density",
    col = "Wave"
  )
```

Additionally, we can sample a few participants and visualise their BMI trajectory over the 14 waves. Note that we add a small amount of random noise to these trajectories. This is because the LISS data are not open source. To request access to the data, please visit [www.lissdata.nl](https://www.lissdata.nl).

```{r}
ggplot(
  mapping = aes(
    x = wave,
    y = bmi,
    col = factor(participant.id)
  ),
  data = liss.data %>%
    group_by(participant.id) %>%
    filter(!is.na(bmi)) %>% # Remove in main
    filter(n() == 14) %>%
    nest() %>%
    ungroup() %>%
    slice_sample(n = 15) %>%
    mutate(participant.id = seq(n())) %>%
    unnest(data) %>%
    mutate(bmi = bmi + rnorm(n(), 0, 0.5))
) +
  geom_line() +
  geom_point() +
  labs(
    x = "Wave",
    y = "BMI",
    col = "Participant"
  )
```

## Physical Activity

```{r}
liss.data %>%
  count(pa.state)
```

```{r}
ggplot() +
  geom_density(
    mapping = aes(x = MVPA, colour = as.factor(sex)),
    data = liss.data %>%
      filter(!is.na(MVPA))
 )
```

```{r}
ggplot() +
  geom_freqpoly(
    mapping = aes(
      x = age,
      colour = as.factor(pa.state)
    ),
    data = liss.data,
    bins = 30
  ) +
  facet_wrap(~ sex)
```

## Smoking

Number of people who ever smoked per wave (only year).

```{r}
liss.data %>%
  count(ever_smoked, wave.year) %>%
  spread(ever_smoked, n) %>%
  rename("yes"="1", "no"="2")
```

Number and percentage of people who smokes at the moment; had smoked before but stopped; and have never smoked:

```{r}
toplot<-liss.data %>%
  add_count(wave.year, name = "n_in_wave") %>%
  filter(is.na(ever_smoked)==FALSE) %>%
  count(smoking_status, wave.year, n_in_wave) %>%
  mutate(percentage=round((n/n_in_wave)*100,2))
ggplot(toplot, aes(x=wave.year, y=n, group=smoking_status))+geom_line(aes(color=smoking_status))
```

```{r}
ggplot(toplot, aes(x=wave.year, y=percentage, group=smoking_status))+geom_line(aes(color=smoking_status))
```

Check transactions again

```{r}
transitions <- liss.data %>%
  filter(
    !is.na(ever_smoked),
    !is.na(smoking_status_corr),
    wave.year < max(wave.year)
  ) %>%
  select(participant.id, sex, wave.year, smoking_status_corr) %>%
  inner_join(
    liss.data %>%
      filter(
        wave.year > min(wave.year),
        !is.na(smoking_status_corr)
      ) %>%
      mutate(wave.year = wave.year - 1) %>%
      select(participant.id, wave.year, smoking_status_corr),
    by = c("participant.id", "wave.year")
  ) %>%
  count(sex, "0" = smoking_status_corr.x, "1" = smoking_status_corr.y) %>%
  mutate(row.id = seq(n())) %>%
  pivot_longer(c("0", "1")) %>%
  mutate(name = as.numeric(name))
transitions
```

[Placeholder for text]

```{r}
ggplot(
  mapping = aes(
    x = name,
    id = row.id,
    split = value,
    value = n
  ),
  data = transitions
) +
  geom_parallel_sets(
    mapping = aes(fill = as.factor(sex)),
    alpha = 0.5,
    axis.width = 0.1
  ) +
  geom_parallel_sets_axes(
    axis.width = 0.1,
    fill = "grey"
  ) +
  geom_parallel_sets_labels() +
  scale_fill_discrete(
    name = "Sex",
    labels = c("Male", "Female")
  ) +
  theme_void()
```

[Placeholder for text]

```{r}
transitions.per.wave <- liss.data %>%
  expand(participant.id, wave) %>%
  left_join(
    liss.data %>%
      filter(
        !is.na(ever_smoked),
        !is.na(smoking_status_corr)
      ) %>%
      select(participant.id, sex, wave, smoking_status_corr),
    by = c("participant.id", "wave")
  ) %>%
  mutate(stratum = ifelse(is.na(smoking_status_corr), "unknown", smoking_status_corr))
transitions.per.wave
```

[Placeholder for text]

```{r}
ggplot(
  mapping = aes(
    x = wave,
    id = participant.id,
    split = stratum,
    value = 1,
    fill = stratum
  ),
  data = transitions.per.wave
) +
  geom_parallel_sets(
    fill = "grey",
    alpha = 0.5
  ) +
  geom_parallel_sets_axes(axis.width = 0.4) +
  scale_x_continuous(
    name = "Wave",
    breaks = seq(13)
  ) +
  scale_fill_discrete(
    name = "Smoke Status",
    labels = c("Never Smoked", "Smokes", "Stopped", "Unknown")
  ) +
  theme_void() +
  theme(
    axis.title.x = element_text(margin = margin(t = 4)),
    axis.text.x = element_text(margin = margin(t = -12))
  )
```

[Placeholder for text]

# Write Output

Finally, we write the cleaned data for the LISS panel to a CSV file.

```{r}
write_csv(
  x = liss.data,
  file = "../../Input Data/Risk Factors/LISS.csv"
)
```

# References

<div id="refs"></div>
